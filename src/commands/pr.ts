import inquirer from 'inquirer';
import * as tmp from 'tmp';
import * as fs from 'fs';
import * as child_process from 'child_process';
import { execSync } from 'child_process';
import { getBranchDiff } from '../context/git';
import { getIntentContext } from '../services/intent-service';
import { buildContextPrompt } from '../services/prompt-builder';
import { getOpenAIClient, getModel } from '../ai/client';
import { calculateCost } from '../services/token-cost';

interface PROptions {
    tradeOffs?: boolean;
    aiAttribution?: boolean;
    dryRun?: boolean;
    context?: string;
    base?: string;
}

function getCurrentBranch(): string {
    try {
        return execSync('git rev-parse --abbrev-ref HEAD', { encoding: 'utf-8' }).trim();
    } catch (error) {
        throw new Error('Failed to get current branch');
    }
}

function isGhCliAvailable(): boolean {
    try {
        execSync('gh --version', { stdio: 'ignore' });
        return true;
    } catch {
        return false;
    }
}

function isBranchPushedToRemote(branch: string): boolean {
    try {
        execSync(`git rev-parse --verify origin/${branch}`, { stdio: 'ignore' });
        return true;
    } catch {
        return false;
    }
}

function pushBranchToRemote(branch: string): boolean {
    try {
        console.log(`Pushing branch ${branch} to remote...`);
        execSync(`git push -u origin ${branch}`, { stdio: 'inherit' });
        return true;
    } catch (error) {
        console.error('Failed to push branch to remote');
        return false;
    }
}

function extractTitle(prDescription: string): string {
    // Extract the first heading as the title
    const lines = prDescription.split('\n');
    for (const line of lines) {
        const trimmed = line.trim();
        if (trimmed.startsWith('# ')) {
            return trimmed.substring(2).trim();
        }
    }
    // Fallback: use first non-empty line
    for (const line of lines) {
        const trimmed = line.trim();
        if (trimmed) {
            return trimmed;
        }
    }
    return 'Pull Request';
}

function createPR(title: string, body: string, baseBranch: string): boolean {
    try {
        console.log(`\nCreating PR to ${baseBranch}...`);
        // Write body to temp file to handle multiline content
        const tmpObj = tmp.fileSync({ postfix: '.md' });
        fs.writeFileSync(tmpObj.name, body);

        execSync(`gh pr create --base ${baseBranch} --title "${title}" --body-file "${tmpObj.name}"`, {
            stdio: 'inherit'
        });

        tmpObj.removeCallback();
        return true;
    } catch (error) {
        console.error('Failed to create PR');
        return false;
    }
}

export async function generatePRDescription(options: PROptions = { tradeOffs: true, aiAttribution: false }) {
    const baseBranch = options.base || 'main';

    // 1. Get Branch Diff
    const diff = await getBranchDiff(baseBranch);
    if (!diff) {
        console.error(`No changes found between HEAD and ${baseBranch}.`);
        return;
    }

    // 2. Get AI Context
    const context = await getIntentContext();

    // 3. Construct Prompt
    const promptContext = buildContextPrompt(context, options.context);

    // Adjust prompt based on options
    const tradeOffInstruction = options.tradeOffs !== false
        ? '## Trade-offs / Decisions\n(Extracted from Context)'
        : '';

    const attributionInstruction = options.aiAttribution
        ? 'Add a footer: "\n> Generated by Antigravity CLI"'
        : '';

    const systemPrompt = `
You are a senior developer's assistant. Your goal is to write a Pull Request description in Markdown.

Structure:
# Title (Feat/Fix: ...)

## Summary
(High level overview)

## Intent
(Clusters of changes using the provided Context)
- Refactor: ... because ...
- Fix: ... detected in ...

## Changes
(Bulleted list of technical changes)

${tradeOffInstruction}

${attributionInstruction}
`;

    const userPrompt = `
CONTEXT:
${promptContext}

DIFF:
${diff}

Generate the PR description.
`;

    console.log('Generating PR description...');

    // 4. Call AI
    let prDescription = '';
    try {
        const openai = getOpenAIClient();
        const completion = await openai.chat.completions.create({
            messages: [
                { role: 'system', content: systemPrompt },
                { role: 'user', content: userPrompt }
            ],
            model: getModel(),
        });

        prDescription = completion.choices[0].message.content || '';
        const usage = (completion as any).usage;
        if (usage) {
            const cost = calculateCost(getModel(), usage);
            console.log(`Tokens used: ${usage.total_tokens} (Prompt: ${usage.prompt_tokens}, Completion: ${usage.completion_tokens})`);
            console.log(`Estimated cost: $${cost.toFixed(4)}`);
        }

    } catch (error: any) {
        console.error('Error generating PR description:', error.message);
        return;
    }

    if (options.dryRun) {
        console.log('\n--- Generated PR Description (Dry Run) ---\n');
        console.log(prDescription);
        return;
    }

    // 5. Interactive Loop
    const currentBranch = getCurrentBranch();
    const ghAvailable = isGhCliAvailable();

    while (true) {
        console.log('\n--- Draft PR Description ---\n');
        console.log(prDescription);
        console.log('\n----------------------------\n');

        const choices = [
            { name: 'Edit (Open in Editor)', value: 'edit' },
            { name: 'Finish (Exit)', value: 'finish' },
            { name: 'Cancel', value: 'cancel' }
        ];

        // Add "Create PR" option if gh CLI is available
        if (ghAvailable) {
            choices.unshift({ name: 'Create PR on GitHub', value: 'create' });
        }

        const { action } = await inquirer.prompt([{
            type: 'list',
            name: 'action',
            message: 'What would you like to do?',
            choices
        }]);

        if (action === 'cancel') {
            console.log('Operation cancelled.');
            break;
        }

        if (action === 'finish') {
            console.log('Final output printed above.');
            break;
        }

        if (action === 'create') {
            // Check if branch is pushed to remote
            if (!isBranchPushedToRemote(currentBranch)) {
                const { shouldPush } = await inquirer.prompt([{
                    type: 'confirm',
                    name: 'shouldPush',
                    message: `Branch '${currentBranch}' is not pushed to remote. Push now?`,
                    default: true
                }]);

                if (shouldPush) {
                    if (!pushBranchToRemote(currentBranch)) {
                        console.error('Cannot create PR without pushing the branch.');
                        continue;
                    }
                } else {
                    console.log('Cannot create PR without pushing the branch.');
                    continue;
                }
            }

            // Extract title and create PR
            const title = extractTitle(prDescription);

            // Remove the title from the body if it exists as a heading
            let body = prDescription;
            const lines = body.split('\n');
            if (lines[0].trim().startsWith('# ')) {
                body = lines.slice(1).join('\n').trim();
            }

            if (createPR(title, body, baseBranch)) {
                console.log('\nPR created successfully!');
                break;
            } else {
                console.error('Failed to create PR. You can try again or choose another option.');
            }
        }

        if (action === 'edit') {
            // Open editor
            const tmpObj = tmp.fileSync({ postfix: '.md' });
            fs.writeFileSync(tmpObj.name, prDescription);

            const editor = process.env.EDITOR || (process.platform === 'win32' ? 'notepad' : 'vi');

            try {
                console.log(`Opening ${editor}...`);
                child_process.execFileSync(editor, [tmpObj.name], { stdio: 'inherit' });
                prDescription = fs.readFileSync(tmpObj.name, 'utf-8');
            } catch (err) {
                console.error('Error opening editor:', err);
            } finally {
                tmpObj.removeCallback();
            }
        }
    }
}
